# 第2章
  计算机以比特序列存储数据，每个比特非0即1。大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字“，存储的基本单位称为”字“，通常由几个字节组成。
    
  大多数计算机将内存中的每个字节与一个数字(被称为地址)关联起来，在一个字节为8比特、字为32比特的机器上，我们可能看到一个字的内存区域如下，其中左侧为字节的地址，右侧是字节中8比特的内容。

地址 | 内容
---- | -----
736424  | 0 0 1 1 1 0 1 1
736425  | 0 0 0 1 1 0 1 1
736426  | 0 1 1 0 0 1 0 0

  选择类型/知晓数值不能为负，选用无符号类型/整数运算，选择int，short常常太小，而long一般和int一个尺寸，数值超过int，使用long long/算术表达式不要使用char或bool，只有存放字符或布尔值才使用，因为char在一些机器是有符号的，在一些机器是无符号的/执行浮点数运算使用double，float通常精度不够而且双精度运算和单精度浮点数的计算代价相差无几。
  
  以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。十进制字面值的类型是int、long和long long，八进制和十六进制字面值的类型是int、unsigned int、long、unsigned long。
  
  初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新的值代替。
  
  声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负创建与名字关联的实体。特别的是定义还申请存储空间，也可能为变量赋一个初始值。如果想声明一个变量而非定义它，就在变量名前添加关键字extern，extern如果包含初始值就不再是声明，而变成定义。
  
  变量能且只能被定义一次，但是可以被多次声明。
  
  变量命名规范，标识符（例如变量名）要能体现实际含义/变量名一般用小写字母，如index，不要使用Index或INDEX
用户自定义的类名一般以大写字母开头，如Bookstore/如果标识符由多个单词组成，单词间应该有区分，如student_boy或studetBoy，不要使用studentboy。

  在初始化变化时，初始值会被拷贝到新建的对象中，在定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用，一旦初始化完成，引用和它的初始化对西那个一直绑定在一起。并且引用不是对象，因此不存在定义引用的引用。
  
  指针和引用的区别，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象/指针无需在定义时赋初值/引用本身并非一个对象，一旦定义了引用，就无法令其再绑定到另外的对象。
  
  如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值，访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。
  
  void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void* 指针存放着一个地址，这一点和其他指针类似，不同的是，我们对该地址中到底是个什么类型的对象并不了解，所以不能直接操作void* 指针所指的对象。
  
  int* &r=p;从右向左阅读r的意义，离变量名最近的符号对变量的类型有最直接的影响。
  
  const对象必须被初始化
  
  如果想再多个文件之间共享const对象，必须在变量定义之前添加extern关键字。
  
  const引用允许将const int&绑定到一个普通的对象上，但是不可逆。
  
  指针和const/指向常量的指针不能用于改变其所指对象的值：
```C++
const double pi=3.14;
double *ptr=&pi;  //错误
const double *cptr=&pi;  //正确
*cptr=42;  //错误
```
  常量指针必须初始化，而且一旦初始化完成，则它的值(地址)就不能再改变：
```C++
int errNumb=0;
int *const curErr=&erNumb; //curErr将一直指向errNumb 
const double pi=3.14;
const double *const pip=&pi; //pip是一个指向常量对象的常量指针
```
  顶层const表示指针本身是一个常量，底层const表示指针所指的对象是一个常量，const int* const p3=p2;//靠右侧const是顶层cosnt，靠左的是底层const//用于声明引用的const都是底层const。
  
  当执行对象拷贝操作时，常量是顶层const和底层const区别明显，顶层const不受什么影响，底层const具有限制，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。
  
  常量表达式指值不会改变并且在编译过程就能得到计算结果的表达式。C++11新标准允许将变量声明为constexpr类型来让编译器验证变量的值是否是一个常量表达式。
```C++
constexpr int a = 20; //对
constexpr int b = a + 1; //对
constexpr int sz = size(); //只有当size是一个constexpr函数时才正确
```
  算术类型、引用、指针都属于字面值类型，自定义类、IO库、string类型则不属于字面值类型。尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格的限制，一个constexpr指针的初始值必须是nullptr或者0，或者存储于某个固定地址中的对象。
  
  如果你认定变量是一个常量表达式(constexpr检测是否常量表达式)，那就把它声明为constexpr类型，其中的关键在于constexpr把它所定义的对象置为了顶层const。
```C++
const int* p=nullptr;  //p是一个指向整数常量的指针
constexpr int* q=nullptr;  //q是一个至西那个整数的常量指针
```
  定义类型别名有两种方式，其一传统方法使用typedef，其二C++11使用别名声明using SI=Sales_item。
  
  C++11新标准引入auto类型说明赋，用它就能让编译器替我们去分析表达式所属的类型，并且auto定义的便利那个必须有初始值。
  
  decltype作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。
  ```C++
  const int ci=-,&cj=ci;
  decltype(ci) x=0;  //x的类型是const int
  decltype(ci) z;  //z是一个引用，必须初始化
 ```
  decltype(())双层括号，里面的的结果永远是一个引用。
    
    auto和decltype的区别：
 ```C++
 int i = 0, &r = i;
// same
auto a = i;
decltype(i) b = i;
// different
auto c = r;
decltype(r) d = r;
 ```
  C++11新标准规定，可以为数据成员提供一个类内初始值，创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。初始化的值放在花括号或等号右边，不能使用圆括号。
  
  头文件保护符依赖于预处理变量，#define指令把一个名字设定为预处理变量，#ifdef当且仅当变量已定义，#ifndef当且仅当变量未定义，一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。
```C++
#ifndef SALES_DATA_H  
#define SALES_DATA_H  
struct Sales_data  
{  
};  
#endif
```
