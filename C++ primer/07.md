# 第七章
  this的目的总是指向“这个”对象，所以this是一个常量指针，我们不允许改变this中保存的地址。
  
  紧跟在参数列表后面的const表示this是一个指向常量的指针，像这样使用const的长远函数被称为常量成员函数。
  
  定义返回this对象的函数
```C++
Sales_data& Sales_data::combine(const Sales_data &rhs){ //特别注意函数的返回类型决定函数调用是否是左值，调用一个返回引用的函数得到左值，其他返回类型得到右值
  units_sold+=rhs.units_sold;
  revenue+=rhs.revenue;
  return *this; //返回调用该函数的对象
}
```
  read(输入)和print(输出)分别接受一个各自IO类型的引用作为其参数，这是因为IO类属于不能被拷贝的类型，因此我们只能通过引用来传递它们。
  
  无论何时只要类的对象被创建，就会执行构造函数，不同于其他成员函数，构造函数不能被声明成const，当我们创建类的一个const对象时，知道构造函数完成初始化过程，对象才能真正取得其“常量”属性。
  
  C++新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上=default来要求编译器生成构造函数，Sales_data()=default。
  
  尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须清楚的一点是，对于某些类来说合成的版本无法正常工作，特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。
  
  我们希望能修改类的某个数据成员，即使是在一个const成员函数内，可以使用在变量的声明中加入mutable关键字，mutable size_t access_ctr。
  
  C++11标准，最好的方式就是把默认值声明为一个类内初始值
```C++
class Window_mgr{
private:
  std::vector<Screen> screens{Screen(24,80,'')};
};
```
  友元定义为一个类，也可以将类中的成员函数定义，需要注意要明确指出该成员函数属于哪个类
  
  成员函数的中使用的名字按照如下方式解析：首先在成员函数内查找该名字的声明，如果成员函数内没有找到，则在类内继续查找，这时类内的所有成员都可以被考虑，如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。
  
  随着构造函数体一开始执行，初始化就完成了，我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值。
  
  编译器只会自动执行一步的类型转换，如果代码中使用了两种转换规则，是错误的，如item.conbine("9-999-99999-9");
  
  抑制构造函数定义的隐式转换，可以通过将构造函数声明explicit加以阻止，此时没有任何构造函数能够用于隐式地创建Salws_data对象，特别注意的是，explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复。
```C++
//发生隐式转换的一种情况时当我们执行拷贝形式的初始化时使用=，不能使用隐式转换过程
Sales_data item1(null_book); //ok
Sales_data item1=null_book; //error
//可以使用显示转换
item.combine(Sales_data(null_book)); //ok
```
  尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数，事实上，一个字面值常量类必须至少提供一个constexpr构造函数。
  
  constexpr构造函数必须既符合构造函数的要求(意味着不能包含返回语句)，又符合constexpr函数的要求(意味着它能拥有的唯一可执行语句就是返回语句)，constexpr构造函数函数体一般来说应该是空的。
  
  有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联，在成员声明之前加上关键字static使其与类相关联在一起。
  
  类的静态成员函数存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据，静态成员函数也不与任何对象绑定在一起，它们不包含this指针，静态成员函数不能声明成const，而且也不能在static函数体内使用this指针。
  
  我们既可以在类的内部也可以在类的外部定义静态成员函数，当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句。
  
  我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr，初始值必须是常量表达式，因为这些成员本身就是常量表达式，static constexpr int period=30;
```C++
//即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员
constexpr int Account::piriod; //一个不带初始值的静态成员的定义
```
  静态成员独立于任何对象，静态数据成员可以是不完全类型，特别的是静态数据成员的类型可以就是它所属的类类型，而非静态数据成员则受到限制，只能声明成它所属类的指针或引用。
```C++
class Bar{
public:
  //...
private:
  static Bar mem1; //ok 静态成员可以是不完全类型
  Bar *mem2; //ok
  Bar mem3; //error 数据成员必须是完全类型
}
```
  静态成员和普通成员的另外一个区别是我们使用静态成员作为默认实参，非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终引发错误。
```C++
class Screen{
public:
  Screen& clear(char=bkground); //表示一个在类中稍后定义的静态成员
private:
  static const char bkground;
}
```
